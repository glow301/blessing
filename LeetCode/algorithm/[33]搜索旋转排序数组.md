## 搜索旋转排序数组
> leetcode - 33

### Description
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

你可以假设数组中不存在重复的元素。

> 你的算法时间复杂度必须是 O(log n) 级别。

### 示例
##### 示例 1:
输入: nums = [4,5,6,7,0,1,2], target = 0  
输出: 4

##### 示例 2:
输入: nums = [4,5,6,7,0,1,2], target = 3  
输出: -1  

### 分析
1. 看到要求时间复杂度是 logN，可以很容易想到使用二分查找。
1. 因为数组是有序数组经过旋转得到的，那么以旋转点为分界点，**左边最小的值**一定**大于右边的最大值**
    * 举例: `[4, 5, 6, 7, 0, 1, 2]`，以 0 为分界点，左边 `[4, 5, 6, 7]` 中的最小值 4， 一定大于右边 `[0, 1, 2]` 中的最大值 2。
1. 那么就可以将数组一分为二，一定是**一半是单调的**，**另一半是非单调**的。
1. 对单调的部分，使用二分查找即可，对于非单调部分，重复上面的操作，继续分成一半单调，一半非单调。
* 注意一下边界问题。

### Code
```go
func search(nums []int, target int) int {
    l := len(nums)  
    if l < 1 {
        return -1
    }
    left, right := 0, l - 1
    for left <= right {
        mid := left + ((right - left) >> 1)
        if nums[mid] == target {
            return mid
        }
        // 这里的等号，是因为，整除的结果总是偏向小的结果
        if nums[left] <= nums[mid] {
            // 这里的等号是为了可以取到最左边的值
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1 
            } else {
                left = mid + 1
            }
        } else {
            // 这里的等号是为了可以取到最右边的值
            if target > nums[mid] && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}
```
