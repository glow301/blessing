## 最小路径和
> leetcode - 64

### Description
给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
* 说明：每次只能向下或者向右移动一步。

### 示例
* 输入:
```
[
    [1,3,1],
    [1,5,1],
    [4,2,1]
]
```
* 输出: 7
* 解释: 因为路径 1→3→1→1→1 的总和最小。

### 分析
* 用 `arr[i][j]` 表示原数组中的元素，`dp[i][j]` 表示走到 `arr[i][j]`元素时，最小的路径和。
* `dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + arr[i][j]`
* 注意一下边界问题的处理即可。

### Code
```go
func minPathSum(arr [][]int) int {
    h := len(arr)
    w := len(arr[0])

    for i := 1; i < w; i++ {
        arr[0][i] += arr[0][i-1]
    }
    for i := 1; i < h; i++ {
        for j := 0; j < w; j++ {
            if j == 0 {
                arr[i][j] += arr[i-1][j];
                continue
            }
            arr[i][j] += min(arr[i-1][j], arr[i][j-1])
        }
    }
    return arr[h-1][w-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```