## 使用最小花费爬楼梯
> leetcode - 746

### Description
数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。
每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。
您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯

### 示例
输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。

输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。

### 分析
使用 dp[i] 表示跳到第 i 阶（不包含 i）楼梯的花费，也就是前 i 个楼梯到花费。
* 因为每次可以跳 1 或 2 阶，所以 dp[0] = 0（没有楼梯可以跳）, dp[1] = 0（跳两步）。
* 跳到第 i 阶，无非两种情况
    * 从第 i-1 阶，跳一步，花费是 cost[i-1] + dp[i-1]
    * 从第 i-2 阶，跳两部，花费是 cost[i-2] + dp[i-2]
* dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])

### Code
```code
func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func minCostClimbingStairs(cost []int) int {
    l := len(cost)
    dp := make([]int, l+1)
    for i := 2; i <= l; i++ {
        a := cost[i-1] + dp[i-1]
        b := cost[i-2] + dp[i-2]
        dp[i] = min(a, b)
    }
    return dp[l]
}
```