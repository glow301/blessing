## 定义
> 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

### 适用场景
* [重叠子问题](#重叠子问题)
* [最优子结构](#最优子结构)
* [无后效性](#无后效性)

### 常见问题
* [最长公共子序列 LCS](#最长公共子序列)
* [最长递增子序列](#最长递增子序列)

#### 重叠子问题
* 在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。

#### 最优子结构
* 如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。

#### 无后效性
* 子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。

### 算法设计步骤
1. 设计状态表达式。
1. 设计状态转移方程。

#### 状态表达式
> 即对问题的一般描述  

我们需要为问题的每一个阶段，设计一个独一无二的表达式来表示它们，并且这个表达式要满足无后效性。

#### 状态转移方程
> 对问题如何由其子问题组成的描述。

#### 后续工作
* 确定边界条件。

### 最长公共子序列
#### 定义
一个数列 S，如果分别是两个或多个已知数列的子序列，且是所有匹配此条件序列中最长的，则 S 称为已知序列的最长公共子序列。

#### 问题描述
* 在一个序列集合中（通常为两个序列）用来查找所有序列中最长子序列的问题。  
* 与查找最长公共子串的问题不同的地方是：子序列**不需要**在原序列中占用**连续**的位置

#### 状态方程
设有二维数组 dp[i][j]，表示序列 X 的第 i 位（不包含），与序列 Y 的第 j 位（不包含）**之前**的最长公共子序列。

#### 状态转移方程
* 如果 X[i] == Y[j]
    * dp[i][j] = dp[i-1][j-1] + 1
* 如果 X[i] != Y[j]
    * dp[i][j] = max(dp[i-1][j], dp[i][j-1])

#### 例题
> UVA - 10405  
##### 题目描述
给定两个字符串序列，打印两个序列之最长公共子序列的长度。

##### 输入
输入包含成对的行。每对的第一行包含了第一个字符串，第二行包含了第二个字符串。每个字符串位于单独的一行，包含的字符数不超过 1,000 个。

##### 输出
对于输入的每对字符串，在一行中打印它们的最长公共子序列的长度。

##### 样例输入
bcacbcabbaccbab  
bccabccbbabacbc  
a1b2c3d4e  
zz1yy2xx3ww4vv  
abcdgh  
aedfhr  
abcdefghijklmnopqrstuvwxyz  
a0b0c0d0e0f0g0h0i0j0k0l0m0n0o0p0q0r0s0t0u0v0w0x0y0z0  
abcdefghijklmnzyxwvutsrqpo  
opqrstuvwxyzabcdefghijklmn  

##### 样例输出
11  
4  
3  
26  
14 

##### 代码
```go
package main

import (
    "fmt"
    "os"
    "bufio"
)

const MAXN = 1005

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    scanner := bufio.NewScanner(os.Stdin)
    for scanner.Scan() {
        str1 := scanner.Text()
        scanner.Scan()
        str2 := scanner.Text()

        var dp [MAXN][MAXN]int
        l1, l2 := len(str1), len(str2)
        for i := 1; i <= l1; i++ {
            for j := 1; j <= l2; j++ {
                if str1[i-1] == str2[j-1] {
                    dp[i][j] = dp[i-1][j-1] + 1
                } else {
                    dp[i][j] = max(dp[i][j-1], dp[i-1][j])
                }
            }
        }
        fmt.Println(dp[l1][l2])
    }
}
```

### 最长递增子序列
> 在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。  
* 最长递增子序列中的元素在原序列中**不一定是连续**的
* dp 并**不是**求最长递增子序列的最优解，它的时间复杂度是 $O(m*n)$。

##### 状态方程
* 用 dp[i] 表示，序列 X 第 i 位（包括）之前，最长递增子序列。
* dp[i] 初始化为 1。

##### 状态转移方程
* dp[i] = max(dp[i], dp[j]+1)，j < i 且 arr[j] < arr[i] 

##### 例题
> POJ - 2533

##### 题目描述
给出一个序列，求出这个序列的最长上升子序列。

序列A的上升子序列B定义如下：
1. B为A的子序列
1. B为严格递增序列

##### 输入
第一行包含一个整数n，表示给出序列的元素个数。

第二行包含n个整数，代表这个序列。
1 <= N <= 1000

##### 输出
输出给出序列的最长子序列的长度。

##### 样例输入
7  
1 7 3 5 9 4 8 

##### 样例输出
4  

##### 代码
```go
package main

import "fmt"

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    for {
        var n int
        _, err := fmt.Scanf("%d\n", &n)
        if err != nil {
            break
        }
        arr := make([]int, n)
        dp  := make([]int, n)
        for i := 0; i < n; i++ {
            fmt.Scanf("%d", &arr[i])
        }

        for i := 0; i < n; i++ {
            dp[i] = 1
            for j := 0; j < i; j++ {
                if arr[j] < arr[i] {
                    dp[i] = max(dp[i], dp[j] + 1)
                }
            }
        }
        fmt.Println(dp[n-1])
    }
}
```